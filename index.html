<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow Trajectory Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        canvas {
            border: 1px solid black;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <h1>Arrow Trajectory Game</h1>
    <canvas id="trajectoryCanvas" width="1200" height="600"></canvas>
    <div id="gameOver" style="display:none; color:red; font-size:2em; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);">Game Over!</div>

    <script>
        const canvas = document.getElementById('trajectoryCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverEl = document.getElementById('gameOver');

        let angle = 45;
        let power = 50;
        let isDragging = false;
        let launchPoint = { x: 150, y: canvas.height - 10 }; // Player at ground level
        let isArrowFlying = false;
        let trajectoryPoints = [];
        let arrowPosition = null;
        let enemies = [];
        let gameOver = false;

        // Fortress setup
        const fortress = {
            x: 75,
            y: canvas.height - 60,
            width: 150,
            height: 50
        };

        function drawFortress() {
            ctx.fillStyle = 'gray';
            ctx.fillRect(fortress.x, fortress.y, fortress.width, fortress.height);
        }

        function calculateArrowTrajectory(angle, power, totalTime = 5) {
            const g = 9.8; // Acceleration due to gravity (m/s^2)
            const angleInRadians = (angle * Math.PI) / 180;
            const initialVelocityX = power * Math.cos(angleInRadians);
            const initialVelocityY = power * Math.sin(angleInRadians);

            const points = [];
            const deltaTime = 0.05;

            for (let t = 0; t <= totalTime; t += deltaTime) {
                const x = initialVelocityX * t;
                const y = initialVelocityY * t - 0.5 * g * t * t;

                // Store height above ground, not below
                if (y >= 0) {
                    points.push({ x, y });
                } else {
                    // If below ground, calculate where it hits
                    const tImpact = initialVelocityY / g;
                    points.push({ x: initialVelocityX * tImpact, y: 0 });
                    break;
                }
            }

            return points;
        }

        function drawTrajectory() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFortress();

            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(launchPoint.x, launchPoint.y, 5, 0, Math.PI * 2);
            ctx.fill();

            if (!isArrowFlying) {
                const trajectory = calculateArrowTrajectory(angle, power);
                const scale = 5;

                // Draw each point of the trajectory
                trajectory.forEach((point, index) => {
                    const canvasX = launchPoint.x + point.x * scale;
                    const canvasY = launchPoint.y - point.y * scale;

                    // Ensure we only draw above or on the ground
                    if (canvasY <= canvas.height) {
                        ctx.beginPath();
                        ctx.arc(canvasX, canvasY, 2, 0, Math.PI * 2);
                        ctx.fillStyle = 'red';
                        ctx.fill();

                        // If this is the last point or hits ground, draw line to ground
                        if (index === trajectory.length - 1 || point.y === 0) {
                            ctx.beginPath();
                            ctx.moveTo(canvasX, canvasY);
                            ctx.lineTo(canvasX, canvas.height);
                            ctx.strokeStyle = 'red';
                            ctx.stroke();
                        }
                    }
                });
            }
        }

        function drawArrow() {
            if (isArrowFlying && arrowPosition) {
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(arrowPosition.x, arrowPosition.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawEnemies() {
            ctx.fillStyle = 'green';
            enemies.forEach(enemy => {
                const enemyY = Math.max(canvas.height - 20, enemy.y);
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemyY);
                ctx.lineTo(enemy.x + 5, enemyY + 10); // Body
                ctx.lineTo(enemy.x - 5, enemyY + 10);
                ctx.closePath();
                ctx.fill();

                // Draw axe
                ctx.beginPath();
                ctx.moveTo(enemy.x + 5, enemyY + 5);
                ctx.lineTo(enemy.x + 15, enemyY + 5);
                ctx.stroke();
            });
        }

        function updateAngleAndPower(mouseX, mouseY) {
            const dx = launchPoint.x - mouseX;
            const dy = mouseY - launchPoint.y;

            angle = Math.atan2(dy, dx) * (180 / Math.PI);
            power = Math.min(Math.sqrt(dx * dx + dy * dy) / 2, 100);
        }

        function startArrowFlight() {
            trajectoryPoints = calculateArrowTrajectory(angle, power);
            if (trajectoryPoints.length > 0) {
                isArrowFlying = true;
                arrowPosition = { x: launchPoint.x, y: launchPoint.y };
                animateArrow();
            }
        }

        function animateArrow() {
            if (trajectoryPoints.length > 0 && !gameOver) {
                const scale = 5;
                const nextPoint = trajectoryPoints.shift();
                arrowPosition.x = launchPoint.x + nextPoint.x * scale;
                arrowPosition.y = launchPoint.y - nextPoint.y * scale;
                // If arrow goes below ground, stop animation
                if (arrowPosition.y >= canvas.height) {
                    isArrowFlying = false;
                    arrowPosition = null;
                }
                drawScene();
                if (isArrowFlying) requestAnimationFrame(animateArrow);
            } else {
                isArrowFlying = false;
                arrowPosition = null;
                drawScene();
            }
        }

        function spawnEnemy() {
            enemies.push({
                x: canvas.width,
                y: canvas.height - 20,
                speed: 1 + Math.random() * 2
            });
        }

        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                enemy.x -= enemy.speed;
                if (enemy.x <= fortress.x + fortress.width && enemy.y > fortress.y) {
                    gameOver = true;
                    return false;
                }
                return true;
            });
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFortress();
            drawTrajectory();
            drawArrow();
            drawEnemies();
            if (gameOver) {
                gameOverEl.style.display = 'block';
            }
        }

        // Event listeners for player interaction
        canvas.addEventListener('mousedown', (event) => {
            if (!gameOver) isDragging = true;
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDragging && !gameOver) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                updateAngleAndPower(mouseX, mouseY);
                drawScene();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (!gameOver) {
                isDragging = false;
                if (!isArrowFlying) {
                    startArrowFlight();
                }
            }
        });

        // Game loop
        function gameLoop() {
            if (!gameOver) {
                if (Math.random() < 0.01) spawnEnemy(); 
                updateEnemies();
                drawScene();
            }
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>